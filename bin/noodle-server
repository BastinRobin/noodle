#!/usr/bin/env node

var connect = require('connect'),
    http    = require('http'),
    util    = require('util'),
    config  = require('../lib/config'),
    scraper = require('../lib/scraper'),

    port    = process.argv[2] || 8888,

    app     = connect()
              .use(connect.query())
              .use(connect.json())
              .use(handle);


function handle (req, res) {
  var hasJSON        = (Object.keys(req.body).length  > 0),
      hasQueryString = (Object.keys(req.query).length > 0),
      queries;

  // Handle for different request types

  // Take JSON from request body (http post)
  queries = (hasJSON) ? req.body : false;
  // Take only single query JSON from request querystring (http get)
  queries = (queries === false && hasQueryString) ? req.query : queries;
  // Take JSON from request querystring (http get)
  queries = (req.query.q) ? JSON.parse(req.query.q) : queries;

  // Scrape the requested data then use finish() to respond to client

  if (queries) {
    scraper.scrape(queries, function (err, results) {
      finish(res, {error: err, results: results, callback: req.query.callback});
    });
  } else {
    finish(res, {error: 'No queries', callback: req.query.callback});
  }
}

// Finish responding to request

function finish (res, params) {
  var error    = params.error,
      callback = params.callback,
      results  = JSON.stringify(params.results);

  if (error && callback) {

    // Error as JSONP

    res.writeHead('401', {'Content-type':'text/javascript; charset=utf-8'});
    res.end(callback + '({"error": "' + error + '"})');

  } else if (error) {

    // Error as JSON

    res.writeHead('401', {'Content-type':'application/json; charset=utf-8'});
    res.end('{"error": "' + error + '"}');

  } else if (callback) {

    // Results as JSONP

    res.writeHead('200', {
      'Content-type': 'text/javascript; charset=utf-8',
      'Expires': setExpiresHeader(params.results)
    });
    res.end(callback + '(' + results + ')');

  } else {

    // Results as JSON

    res.writeHead('200', {
      'Content-type': 'application/json; charset=utf-8',
      'Expires': setExpiresHeader(params.results)
    });
    res.end(results);
  }
}

function setExpiresHeader (results) {

  // Normalise results to array and get the oldest 
  // time first (sooner to expire)

  results = (util.isArray(results)) ? results : [results];
  
  results.sort(function (a, b) {
    var timeA = a.created || 0,
        timeB = b.created || 0;

    return timeA - timeB;
  });

  // Return soonest to expire or return the present time

  if (results[0].created) {
    return new Date(results[0].created.getTime() + config.cacheMaxTime);
  } else {
    return new Date();
  }
}

http.createServer(app).listen(port, function () {
  console.log('noodle serving on ' + port);
});